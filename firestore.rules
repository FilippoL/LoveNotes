rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    function getUserPairId() {
      let userData = getUserData();
      return userData.partnerId;
    }
    
    function isUserInPair(pairId) {
      return getUserPairId() == pairId;
    }
    
    // Helper function to check if updating partner connection fields
    function isPartnerConnectionUpdate() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['partnerId', 'connectionStatus']) 
             || affectedKeys.hasOnly(['partnerId']) 
             || affectedKeys.hasOnly(['connectionStatus']);
    }
    
    // Helper function to check if user is in a pair with the target user
    // Pair IDs are created as sorted userIds: "userId1_userId2" where userId1 < userId2
    function isInPairWith(targetUserId) {
      let currentUserId = request.auth.uid;
      // Sort IDs to match pairId format (alphabetically sorted)
      let pairId = currentUserId < targetUserId 
                   ? currentUserId + '_' + targetUserId
                   : targetUserId + '_' + currentUserId;
      let pairDoc = get(/databases/$(database)/documents/pairs/$(pairId));
      // Check if pair exists and includes both users (for pairing)
      let pairExists = pairDoc != null 
                       && (pairDoc.data.user1Id == currentUserId || pairDoc.data.user2Id == currentUserId)
                       && (pairDoc.data.user1Id == targetUserId || pairDoc.data.user2Id == targetUserId);
      // For breakup: check if target user's current partnerId matches the expected pairId
      // and we're setting partnerId to null
      let targetUserPartnerId = resource.data.partnerId;
      let isBreakup = targetUserPartnerId != null 
                      && targetUserPartnerId == pairId
                      && request.resource.data.partnerId == null;
      return pairExists || isBreakup;
    }
    
    // Users collection
    match /users/{userId} {
      // Allow authenticated users to read user documents (needed for pairing checks)
      // Users can read their own document or other users' documents
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() 
                    && request.auth.uid == userId
                    && request.resource.data.keys().hasAll(['email', 'publicKey'])
                    && request.resource.data.email is string
                    && request.resource.data.publicKey is string;
      allow update: if isAuthenticated() 
                    && (
                      // User can update their own document (except publicKey)
                      (request.auth.uid == userId
                       && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['publicKey']))
                      ||
                      // User can update partner's document when setting up/breaking up a pair
                      (request.auth.uid != userId
                       && isPartnerConnectionUpdate()
                       && isInPairWith(userId))
                    );
    }
    
    // Pairs collection
    match /pairs/{pairId} {
      allow read: if isAuthenticated() && isUserInPair(pairId);
      allow create: if isAuthenticated() 
                    && request.resource.data.keys().hasAll(['user1Id', 'user2Id', 'createdAt'])
                    && (request.resource.data.user1Id == request.auth.uid 
                        || request.resource.data.user2Id == request.auth.uid);
      allow update: if isAuthenticated() && isUserInPair(pairId);
      allow delete: if isAuthenticated() && isUserInPair(pairId);
    }
    
    // Cards collection
    match /cards/{cardId} {
      allow read: if isAuthenticated() 
                  && resource.data.pairId == getUserPairId();
      allow create: if isAuthenticated() 
                    && request.resource.data.keys().hasAll(['pairId', 'creatorId', 'encryptedContent', 'contentType', 'createdAt', 'isRead'])
                    && request.resource.data.creatorId == request.auth.uid
                    && request.resource.data.pairId == getUserPairId()
                    && request.resource.data.contentType in ['text', 'voice']
                    && request.resource.data.isRead == false;
      allow update: if isAuthenticated() 
                    && resource.data.pairId == getUserPairId()
                    && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['encryptedContent', 'creatorId', 'pairId']));
      allow delete: if false; // Cards are never deleted, only marked as read
    }
    
    // Draw history collection - structure: drawHistory/{pairId}/draws/{drawId}
    match /drawHistory/{pairId}/draws/{drawId} {
      allow read: if isAuthenticated() && isUserInPair(pairId);
      allow create: if isAuthenticated() 
                    && request.resource.data.keys().hasAll(['cardId', 'drawnAt', 'viewedBy'])
                    && request.resource.data.viewedBy == request.auth.uid
                    && isUserInPair(pairId);
    }
    
    // Helper function to check if user is accepting an invite (pair exists with invite creator)
    function isAcceptingInvite(inviteCreatorId) {
      let currentUserId = request.auth.uid;
      // Sort IDs to match pairId format
      let pairId = currentUserId < inviteCreatorId 
                   ? currentUserId + '_' + inviteCreatorId
                   : inviteCreatorId + '_' + currentUserId;
      let pairDoc = get(/databases/$(database)/documents/pairs/$(pairId));
      return pairDoc != null 
             && (pairDoc.data.user1Id == currentUserId || pairDoc.data.user2Id == currentUserId)
             && (pairDoc.data.user1Id == inviteCreatorId || pairDoc.data.user2Id == inviteCreatorId);
    }
    
    // Invite codes collection
    match /inviteCodes/{codeId} {
      allow read: if isAuthenticated(); // Anyone authenticated can read invite codes
      allow create: if isAuthenticated() 
                    && request.resource.data.keys().hasAll(['code', 'publicKey', 'userId', 'createdAt'])
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.publicKey is string
                    && request.resource.data.code is string;
      // Allow creator to delete, or allow deletion if user is accepting the invite (pair exists)
      allow delete: if isAuthenticated() 
                    && (resource.data.userId == request.auth.uid // Creator can delete
                        || isAcceptingInvite(resource.data.userId)); // Accepter can delete after pairing
    }
  }
}

